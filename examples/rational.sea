gcd: func = (a: i64, b: i64) -> (result: i64) {
  # If A=0 then GCD(A, B)=B since the Greatest Common Divisor of 0 and B is B.
  # If B=0 then GCD(a,b)=a since the Greatest Common Divisor of 0 and a is a.
  # Let R be the remainder of dividing A by B assuming A > B. (R = A % B)
  # Find GCD( B, R ) because GCD( A, B ) = GCD( B, R ). Use the above steps again.
  
  loop a != 0 || b != 0 {
    new_a: i64 = b
    new_b: i64 = a % b
  }
  
  if a == 0 {
    result = b
  } else if b == 0 {
    result = a
  }
}

abs: func = (a: i64) -> (result: i64) {
  if a < 0 {
    result = -a
  } else {
    result = a
  }
}

lcm: func = (a: i64, b: i64) -> (result: i64 = abs(a) * abs(b) / gcd(a, b))

op _+_ left = (x: auto T, y: T) -> (result: T = add(x, y))

op _-_ left = (x: auto T, y: T) -> (result: T = subtract(x, y))

pack rational {
  numerator: i64
  denominator: i64
}

add: func = (a: rational, b: rational) -> (result: rational) {
  mul: i64 = lcm(a.denominator, b.denominator)
  res = { a.numerator * mul + b.numerator * mul, mul };
}

subtract: func = (a: rational, b: rational) -> (res: rational) {
  mul: i64 = lcm(a.denominator, b.denominator)
  res = { a.numerator * mul - b.numerator * mul, mul };
}